#!/usr/bin/env bash
#
# Author: Pooya Moradi
# Date : 2021-08-19
# License: MIT
# Description: A simple dmenu-driven client for repology.org
# Dependencies: jq fq curl notify-send xdg-open
#               dmenu | rofi | fuzzel
# TODO apparently these are unsupported by API v1:
#      - get package link on selection
#      - multi-string package names sometimes don't work
#      - fuzzy search for package name

version=0.9
user_agent="pac-menu-v$version" # client-id per ToS https://repology.org/api/v1
selector_app="dmenu"            # rofi fuzzel
selector_font="monospace-9"
priority_repo="debian"   # distro to show first
use_custom_redirection=0 # ignore repology's project url for custom repos
base_link="https://repology.org"
query_menu_mode=0

show_help() {
    cat << EOF
Display packaging status in different repositories via repology.org

Usage: pac-menu [OPTIONS] PACKAGE-NAME
Options:
    -d : Use selector menu to enter package-name
    -V : Print version
    -h : Print help message
EOF
}

selector() {
    prompt_str="$1"
    lines="$2"
    local args=()
    args+=(-i -p "$prompt_str" -l "$lines" -fn "$selector_font")
    case $selector_app in
        dmenu)
            dmenu "${args[@]}"
            ;;
        rofi)
            rofi -dmenu "${args[@]}"
            ;;
        fuzzel)
            fuzzel --dmenu "${args[@]}"
            ;;
        *)
            log error "unsupported selector app: $selector_app"
            return 1
            ;;
    esac
}

get_response() {
    local query="$1"
    if ! query=$(jq -e -rn --arg q "$query" '$q | @uri'); then
        return 1
    fi
    if ! curl --silent --fail --user-agent "$user_agent" \
        --get "$base_link/api/v1/project/$query"; then
        printf >&2 "Problem in connecting to %s\n" "$base_link"
        notify-send -i package "pac-menu: $query" \
            "Problem in connecting to $base_link\n"
        return 1
    fi
}

# FIXME API does not provide a fuzzy search for package name
search() {
    local query
    query="$1"
    # getting the response json
    local response
    if ! response=$(curl --silent --fail --user-agent "$user_agent" \
        --get "$base_link/api/v1/projects/" \
        --data-urlencode "search=$query"); then
        printf >&2 "Problem in connecting to %s\n" "$base_link"
        notify-send -i package "pac-menu: $query" \
            "Problem in connecting to $base_link\n"
        return 1
    fi
    jq -c . <<< "$response"
}

extract_project_url() {
    local query="$1"
    local repo="$2"
    if [[ -z "$query" ]] || [[ -z "$repo" ]]; then
        return 1
    fi
    local url="$base_link/project/$query/versions"
    local resp_html

    if ! resp_html=$(curl --silent --fail --user-agent "$user_agent" \
        --get "$url"); then
        printf >&2 "Problem in connecting to %s\n" "$url"
        notify-send -i package "pac-menu: $query" \
            "Problem in connecting to $url\n"
        return 1
    fi

    # shellcheck disable=2016
    # the filter here would probably break if repology UI changes
    if ! fq -r --arg p "$repo" \
        '(.. | objects | select(."@id" == $p).td[1].a."@href")
          // error("href not found for " + $p)' \
        <<< "$resp_html"; then
        printf >&2 "Problem in filtering json response\n"
        return 1
    fi
}

get_custom_project_url() {
    local query="$1"
    local repo="$2"
    case "$repo" in
        *debian*)
            printf "https://tracker.debian.org/pkg/%s" "$query"
            ;;
        *)
            return 1
            ;;
    esac
}

refine_query() {
    local query="$1"
    local search_res
    if ! search_res=$(search "$query"); then
        return 1
    fi
    if jq -e 'length == 0' &> /dev/null <<< "$search_res"; then
        printf >&2 "No package found by name: %s\n" "$query"
        notify-send -i package "pac-menu: $query" \
            "No package found by name: $query"
        return 1
    fi
    if ! jq -r -e 'keys[]' <<< "$search_res" \
        | selector "refine $query:" "6"; then
        return 1
    fi
}

process() {
    local query
    query="$1"

    # first try to get the package listing with the passed query
    local response
    if ! response=$(get_response "$query"); then
        return 1
    fi

    # refine the query if such package doesn't exist according to repology.org
    if jq -e 'length == 0' <<< "$response"; then
        if ! query=$(refine_query "$query"); then
            return 1
        fi
        if ! response=$(get_response "$query"); then
            return 1
        fi
        if jq -e 'length == 0' &> /dev/null <<< "$response"; then
            printf >&2 "No package found by name: %s\n" "$query"
            notify-send -i package "pac-menu: $query" \
                "No package found by name: $query"
            return 1
        fi
    fi

    # use symbols for package state
    if ! response=$(jq -e --arg fav "$priority_repo" \
        '.[].status
            |= {newest      :   "‚úÖ", # ‚úî
                outdated    :   "‚ûñ", # ‚Äí
                ignored     :   "i",  # i
                unique      :   "U",  # U
                devel       :   "‚å®Ô∏è", # üñÆ
                legacy      :   "üóø", # ‚á©
                incorrect   :   "‚ùå", # √ó
                untrusted   :   "‚ö†Ô∏è", # !
                noscheme    :   "N",  # N
                rolling     :   "‚ùï"} # ‚Üª
                [.]
                | sort_by([(.repo | (if (. | contains($fav)) then 0
                                                             else 1 end)),
                            .repo])
                ' \
        <<< "$response"); then
        printf >&2 "Problem in filtering json response\n"
        return 1
    fi

    local item
    local visiblename status repo p_version summary
    # instead of | or comma, we use U+001F: Information Separator One
    item=$(jq -r '. [] | [.visiblename, .status, .repo, .version, .summary
                   | select(. != null) ] | map(gsub("\\n"; " "))
                   | join("\u001F")' \
        <<< "$response" \
        | while IFS=$'\x1F' \
            read -r visiblename status repo p_version summary; do
            printf "%-30s %-s %-30s %-25s %s\n" \
                "$visiblename" "$status" "$repo" "$p_version" "$summary"
        done \
        | {
            printf "%-30s %-s %-30s %-25s %s\n" \
                "Package" "‚óâ" "Repository" "Version" "Summary"
            cat
        } \
        | selector "$query:" "6")
    local q_url
    # FIXME return the url of selected project when API supports this
    q_url="$item"
    [[ -z "$q_url" ]] && return 1

    # for now, we extract the link from yet another GET request
    repo=$(awk '{for (i=1;i<NF;i++) if ($(i+1) ~ /^[0-9]/)
                                       {print $i; exit}}' <<< "$item")
    if [[ "${item%% *}" == "Package" ]]; then
        # set the URL to package listing webpage
        q_url="$base_link/project/$query/versions"

    elif ((use_custom_redirection)) \
        && q_url=$(get_custom_project_url \
            "$(awk '{print $1}' <<< "$item")" \
            "$repo"); then
        # first handle special cases where repology-reported project-url is less
        # useful
        # like using tracker.debian.org instead of packages.debian.org
        :
    else
        # get repology project url via filtering project listing webpage
        if ! q_url=$(extract_project_url "$query" "$repo"); then
            return 1
        fi
    fi
    xdg-open "$q_url"
}

while getopts Vhd opt; do
    case $opt in
        h)
            show_help
            exit
            ;;
        V)
            printf "%s\n" "$version"
            exit
            ;;
        d)
            query_menu_mode=1
            ;;
        *)
            printf >&2 "Bad usage! Check -h\n"
            exit 2
            ;;
    esac
done
shift "$((OPTIND - 1))"

# capture query string
if ((query_menu_mode)); then
    if ! query=$(selector 'Repology [query]:' '1' < /dev/null); then
        exit
    fi
    [[ -z "$query" ]] && exit 1
else
    query="$*"

    if [[ -z "$query" ]]; then
        show_help
        exit 2
    fi
fi

# sanitize the query
query="${query// /-}"

if ! q_url=$(process "$query"); then
    exit 1
fi
